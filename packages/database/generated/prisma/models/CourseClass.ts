
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `CourseClass` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model CourseClass
 * 
 */
export type CourseClassModel = runtime.Types.Result.DefaultSelection<Prisma.$CourseClassPayload>

export type AggregateCourseClass = {
  _count: CourseClassCountAggregateOutputType | null
  _min: CourseClassMinAggregateOutputType | null
  _max: CourseClassMaxAggregateOutputType | null
}

export type CourseClassMinAggregateOutputType = {
  id: string | null
  courseId: string | null
  classId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type CourseClassMaxAggregateOutputType = {
  id: string | null
  courseId: string | null
  classId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type CourseClassCountAggregateOutputType = {
  id: number
  courseId: number
  classId: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type CourseClassMinAggregateInputType = {
  id?: true
  courseId?: true
  classId?: true
  createdAt?: true
  updatedAt?: true
}

export type CourseClassMaxAggregateInputType = {
  id?: true
  courseId?: true
  classId?: true
  createdAt?: true
  updatedAt?: true
}

export type CourseClassCountAggregateInputType = {
  id?: true
  courseId?: true
  classId?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type CourseClassAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CourseClass to aggregate.
   */
  where?: Prisma.CourseClassWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CourseClasses to fetch.
   */
  orderBy?: Prisma.CourseClassOrderByWithRelationInput | Prisma.CourseClassOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.CourseClassWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CourseClasses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CourseClasses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned CourseClasses
  **/
  _count?: true | CourseClassCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: CourseClassMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: CourseClassMaxAggregateInputType
}

export type GetCourseClassAggregateType<T extends CourseClassAggregateArgs> = {
      [P in keyof T & keyof AggregateCourseClass]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateCourseClass[P]>
    : Prisma.GetScalarType<T[P], AggregateCourseClass[P]>
}




export type CourseClassGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CourseClassWhereInput
  orderBy?: Prisma.CourseClassOrderByWithAggregationInput | Prisma.CourseClassOrderByWithAggregationInput[]
  by: Prisma.CourseClassScalarFieldEnum[] | Prisma.CourseClassScalarFieldEnum
  having?: Prisma.CourseClassScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: CourseClassCountAggregateInputType | true
  _min?: CourseClassMinAggregateInputType
  _max?: CourseClassMaxAggregateInputType
}

export type CourseClassGroupByOutputType = {
  id: string
  courseId: string
  classId: string
  createdAt: Date
  updatedAt: Date
  _count: CourseClassCountAggregateOutputType | null
  _min: CourseClassMinAggregateOutputType | null
  _max: CourseClassMaxAggregateOutputType | null
}

type GetCourseClassGroupByPayload<T extends CourseClassGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<CourseClassGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof CourseClassGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], CourseClassGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], CourseClassGroupByOutputType[P]>
      }
    >
  >



export type CourseClassWhereInput = {
  AND?: Prisma.CourseClassWhereInput | Prisma.CourseClassWhereInput[]
  OR?: Prisma.CourseClassWhereInput[]
  NOT?: Prisma.CourseClassWhereInput | Prisma.CourseClassWhereInput[]
  id?: Prisma.StringFilter<"CourseClass"> | string
  courseId?: Prisma.StringFilter<"CourseClass"> | string
  classId?: Prisma.StringFilter<"CourseClass"> | string
  createdAt?: Prisma.DateTimeFilter<"CourseClass"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"CourseClass"> | Date | string
  course?: Prisma.XOR<Prisma.CourseScalarRelationFilter, Prisma.CourseWhereInput>
  className?: Prisma.XOR<Prisma.ClassNameScalarRelationFilter, Prisma.ClassNameWhereInput>
}

export type CourseClassOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  classId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  course?: Prisma.CourseOrderByWithRelationInput
  className?: Prisma.ClassNameOrderByWithRelationInput
}

export type CourseClassWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  courseId_classId?: Prisma.CourseClassCourseIdClassIdCompoundUniqueInput
  AND?: Prisma.CourseClassWhereInput | Prisma.CourseClassWhereInput[]
  OR?: Prisma.CourseClassWhereInput[]
  NOT?: Prisma.CourseClassWhereInput | Prisma.CourseClassWhereInput[]
  courseId?: Prisma.StringFilter<"CourseClass"> | string
  classId?: Prisma.StringFilter<"CourseClass"> | string
  createdAt?: Prisma.DateTimeFilter<"CourseClass"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"CourseClass"> | Date | string
  course?: Prisma.XOR<Prisma.CourseScalarRelationFilter, Prisma.CourseWhereInput>
  className?: Prisma.XOR<Prisma.ClassNameScalarRelationFilter, Prisma.ClassNameWhereInput>
}, "id" | "courseId_classId">

export type CourseClassOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  classId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.CourseClassCountOrderByAggregateInput
  _max?: Prisma.CourseClassMaxOrderByAggregateInput
  _min?: Prisma.CourseClassMinOrderByAggregateInput
}

export type CourseClassScalarWhereWithAggregatesInput = {
  AND?: Prisma.CourseClassScalarWhereWithAggregatesInput | Prisma.CourseClassScalarWhereWithAggregatesInput[]
  OR?: Prisma.CourseClassScalarWhereWithAggregatesInput[]
  NOT?: Prisma.CourseClassScalarWhereWithAggregatesInput | Prisma.CourseClassScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"CourseClass"> | string
  courseId?: Prisma.StringWithAggregatesFilter<"CourseClass"> | string
  classId?: Prisma.StringWithAggregatesFilter<"CourseClass"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"CourseClass"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"CourseClass"> | Date | string
}

export type CourseClassCreateInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  course: Prisma.CourseCreateNestedOneWithoutClassesInput
  className: Prisma.ClassNameCreateNestedOneWithoutCoursesInput
}

export type CourseClassUncheckedCreateInput = {
  id?: string
  courseId: string
  classId: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CourseClassUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  course?: Prisma.CourseUpdateOneRequiredWithoutClassesNestedInput
  className?: Prisma.ClassNameUpdateOneRequiredWithoutCoursesNestedInput
}

export type CourseClassUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  classId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CourseClassCreateManyInput = {
  id?: string
  courseId: string
  classId: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CourseClassUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CourseClassUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  classId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CourseClassListRelationFilter = {
  every?: Prisma.CourseClassWhereInput
  some?: Prisma.CourseClassWhereInput
  none?: Prisma.CourseClassWhereInput
}

export type CourseClassOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type CourseClassCourseIdClassIdCompoundUniqueInput = {
  courseId: string
  classId: string
}

export type CourseClassCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  classId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type CourseClassMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  classId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type CourseClassMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  classId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type CourseClassCreateNestedManyWithoutClassNameInput = {
  create?: Prisma.XOR<Prisma.CourseClassCreateWithoutClassNameInput, Prisma.CourseClassUncheckedCreateWithoutClassNameInput> | Prisma.CourseClassCreateWithoutClassNameInput[] | Prisma.CourseClassUncheckedCreateWithoutClassNameInput[]
  connectOrCreate?: Prisma.CourseClassCreateOrConnectWithoutClassNameInput | Prisma.CourseClassCreateOrConnectWithoutClassNameInput[]
  createMany?: Prisma.CourseClassCreateManyClassNameInputEnvelope
  connect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
}

export type CourseClassUncheckedCreateNestedManyWithoutClassNameInput = {
  create?: Prisma.XOR<Prisma.CourseClassCreateWithoutClassNameInput, Prisma.CourseClassUncheckedCreateWithoutClassNameInput> | Prisma.CourseClassCreateWithoutClassNameInput[] | Prisma.CourseClassUncheckedCreateWithoutClassNameInput[]
  connectOrCreate?: Prisma.CourseClassCreateOrConnectWithoutClassNameInput | Prisma.CourseClassCreateOrConnectWithoutClassNameInput[]
  createMany?: Prisma.CourseClassCreateManyClassNameInputEnvelope
  connect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
}

export type CourseClassUpdateManyWithoutClassNameNestedInput = {
  create?: Prisma.XOR<Prisma.CourseClassCreateWithoutClassNameInput, Prisma.CourseClassUncheckedCreateWithoutClassNameInput> | Prisma.CourseClassCreateWithoutClassNameInput[] | Prisma.CourseClassUncheckedCreateWithoutClassNameInput[]
  connectOrCreate?: Prisma.CourseClassCreateOrConnectWithoutClassNameInput | Prisma.CourseClassCreateOrConnectWithoutClassNameInput[]
  upsert?: Prisma.CourseClassUpsertWithWhereUniqueWithoutClassNameInput | Prisma.CourseClassUpsertWithWhereUniqueWithoutClassNameInput[]
  createMany?: Prisma.CourseClassCreateManyClassNameInputEnvelope
  set?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  disconnect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  delete?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  connect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  update?: Prisma.CourseClassUpdateWithWhereUniqueWithoutClassNameInput | Prisma.CourseClassUpdateWithWhereUniqueWithoutClassNameInput[]
  updateMany?: Prisma.CourseClassUpdateManyWithWhereWithoutClassNameInput | Prisma.CourseClassUpdateManyWithWhereWithoutClassNameInput[]
  deleteMany?: Prisma.CourseClassScalarWhereInput | Prisma.CourseClassScalarWhereInput[]
}

export type CourseClassUncheckedUpdateManyWithoutClassNameNestedInput = {
  create?: Prisma.XOR<Prisma.CourseClassCreateWithoutClassNameInput, Prisma.CourseClassUncheckedCreateWithoutClassNameInput> | Prisma.CourseClassCreateWithoutClassNameInput[] | Prisma.CourseClassUncheckedCreateWithoutClassNameInput[]
  connectOrCreate?: Prisma.CourseClassCreateOrConnectWithoutClassNameInput | Prisma.CourseClassCreateOrConnectWithoutClassNameInput[]
  upsert?: Prisma.CourseClassUpsertWithWhereUniqueWithoutClassNameInput | Prisma.CourseClassUpsertWithWhereUniqueWithoutClassNameInput[]
  createMany?: Prisma.CourseClassCreateManyClassNameInputEnvelope
  set?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  disconnect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  delete?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  connect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  update?: Prisma.CourseClassUpdateWithWhereUniqueWithoutClassNameInput | Prisma.CourseClassUpdateWithWhereUniqueWithoutClassNameInput[]
  updateMany?: Prisma.CourseClassUpdateManyWithWhereWithoutClassNameInput | Prisma.CourseClassUpdateManyWithWhereWithoutClassNameInput[]
  deleteMany?: Prisma.CourseClassScalarWhereInput | Prisma.CourseClassScalarWhereInput[]
}

export type CourseClassCreateNestedManyWithoutCourseInput = {
  create?: Prisma.XOR<Prisma.CourseClassCreateWithoutCourseInput, Prisma.CourseClassUncheckedCreateWithoutCourseInput> | Prisma.CourseClassCreateWithoutCourseInput[] | Prisma.CourseClassUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.CourseClassCreateOrConnectWithoutCourseInput | Prisma.CourseClassCreateOrConnectWithoutCourseInput[]
  createMany?: Prisma.CourseClassCreateManyCourseInputEnvelope
  connect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
}

export type CourseClassUncheckedCreateNestedManyWithoutCourseInput = {
  create?: Prisma.XOR<Prisma.CourseClassCreateWithoutCourseInput, Prisma.CourseClassUncheckedCreateWithoutCourseInput> | Prisma.CourseClassCreateWithoutCourseInput[] | Prisma.CourseClassUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.CourseClassCreateOrConnectWithoutCourseInput | Prisma.CourseClassCreateOrConnectWithoutCourseInput[]
  createMany?: Prisma.CourseClassCreateManyCourseInputEnvelope
  connect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
}

export type CourseClassUpdateManyWithoutCourseNestedInput = {
  create?: Prisma.XOR<Prisma.CourseClassCreateWithoutCourseInput, Prisma.CourseClassUncheckedCreateWithoutCourseInput> | Prisma.CourseClassCreateWithoutCourseInput[] | Prisma.CourseClassUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.CourseClassCreateOrConnectWithoutCourseInput | Prisma.CourseClassCreateOrConnectWithoutCourseInput[]
  upsert?: Prisma.CourseClassUpsertWithWhereUniqueWithoutCourseInput | Prisma.CourseClassUpsertWithWhereUniqueWithoutCourseInput[]
  createMany?: Prisma.CourseClassCreateManyCourseInputEnvelope
  set?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  disconnect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  delete?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  connect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  update?: Prisma.CourseClassUpdateWithWhereUniqueWithoutCourseInput | Prisma.CourseClassUpdateWithWhereUniqueWithoutCourseInput[]
  updateMany?: Prisma.CourseClassUpdateManyWithWhereWithoutCourseInput | Prisma.CourseClassUpdateManyWithWhereWithoutCourseInput[]
  deleteMany?: Prisma.CourseClassScalarWhereInput | Prisma.CourseClassScalarWhereInput[]
}

export type CourseClassUncheckedUpdateManyWithoutCourseNestedInput = {
  create?: Prisma.XOR<Prisma.CourseClassCreateWithoutCourseInput, Prisma.CourseClassUncheckedCreateWithoutCourseInput> | Prisma.CourseClassCreateWithoutCourseInput[] | Prisma.CourseClassUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.CourseClassCreateOrConnectWithoutCourseInput | Prisma.CourseClassCreateOrConnectWithoutCourseInput[]
  upsert?: Prisma.CourseClassUpsertWithWhereUniqueWithoutCourseInput | Prisma.CourseClassUpsertWithWhereUniqueWithoutCourseInput[]
  createMany?: Prisma.CourseClassCreateManyCourseInputEnvelope
  set?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  disconnect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  delete?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  connect?: Prisma.CourseClassWhereUniqueInput | Prisma.CourseClassWhereUniqueInput[]
  update?: Prisma.CourseClassUpdateWithWhereUniqueWithoutCourseInput | Prisma.CourseClassUpdateWithWhereUniqueWithoutCourseInput[]
  updateMany?: Prisma.CourseClassUpdateManyWithWhereWithoutCourseInput | Prisma.CourseClassUpdateManyWithWhereWithoutCourseInput[]
  deleteMany?: Prisma.CourseClassScalarWhereInput | Prisma.CourseClassScalarWhereInput[]
}

export type CourseClassCreateWithoutClassNameInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  course: Prisma.CourseCreateNestedOneWithoutClassesInput
}

export type CourseClassUncheckedCreateWithoutClassNameInput = {
  id?: string
  courseId: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CourseClassCreateOrConnectWithoutClassNameInput = {
  where: Prisma.CourseClassWhereUniqueInput
  create: Prisma.XOR<Prisma.CourseClassCreateWithoutClassNameInput, Prisma.CourseClassUncheckedCreateWithoutClassNameInput>
}

export type CourseClassCreateManyClassNameInputEnvelope = {
  data: Prisma.CourseClassCreateManyClassNameInput | Prisma.CourseClassCreateManyClassNameInput[]
  skipDuplicates?: boolean
}

export type CourseClassUpsertWithWhereUniqueWithoutClassNameInput = {
  where: Prisma.CourseClassWhereUniqueInput
  update: Prisma.XOR<Prisma.CourseClassUpdateWithoutClassNameInput, Prisma.CourseClassUncheckedUpdateWithoutClassNameInput>
  create: Prisma.XOR<Prisma.CourseClassCreateWithoutClassNameInput, Prisma.CourseClassUncheckedCreateWithoutClassNameInput>
}

export type CourseClassUpdateWithWhereUniqueWithoutClassNameInput = {
  where: Prisma.CourseClassWhereUniqueInput
  data: Prisma.XOR<Prisma.CourseClassUpdateWithoutClassNameInput, Prisma.CourseClassUncheckedUpdateWithoutClassNameInput>
}

export type CourseClassUpdateManyWithWhereWithoutClassNameInput = {
  where: Prisma.CourseClassScalarWhereInput
  data: Prisma.XOR<Prisma.CourseClassUpdateManyMutationInput, Prisma.CourseClassUncheckedUpdateManyWithoutClassNameInput>
}

export type CourseClassScalarWhereInput = {
  AND?: Prisma.CourseClassScalarWhereInput | Prisma.CourseClassScalarWhereInput[]
  OR?: Prisma.CourseClassScalarWhereInput[]
  NOT?: Prisma.CourseClassScalarWhereInput | Prisma.CourseClassScalarWhereInput[]
  id?: Prisma.StringFilter<"CourseClass"> | string
  courseId?: Prisma.StringFilter<"CourseClass"> | string
  classId?: Prisma.StringFilter<"CourseClass"> | string
  createdAt?: Prisma.DateTimeFilter<"CourseClass"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"CourseClass"> | Date | string
}

export type CourseClassCreateWithoutCourseInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  className: Prisma.ClassNameCreateNestedOneWithoutCoursesInput
}

export type CourseClassUncheckedCreateWithoutCourseInput = {
  id?: string
  classId: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CourseClassCreateOrConnectWithoutCourseInput = {
  where: Prisma.CourseClassWhereUniqueInput
  create: Prisma.XOR<Prisma.CourseClassCreateWithoutCourseInput, Prisma.CourseClassUncheckedCreateWithoutCourseInput>
}

export type CourseClassCreateManyCourseInputEnvelope = {
  data: Prisma.CourseClassCreateManyCourseInput | Prisma.CourseClassCreateManyCourseInput[]
  skipDuplicates?: boolean
}

export type CourseClassUpsertWithWhereUniqueWithoutCourseInput = {
  where: Prisma.CourseClassWhereUniqueInput
  update: Prisma.XOR<Prisma.CourseClassUpdateWithoutCourseInput, Prisma.CourseClassUncheckedUpdateWithoutCourseInput>
  create: Prisma.XOR<Prisma.CourseClassCreateWithoutCourseInput, Prisma.CourseClassUncheckedCreateWithoutCourseInput>
}

export type CourseClassUpdateWithWhereUniqueWithoutCourseInput = {
  where: Prisma.CourseClassWhereUniqueInput
  data: Prisma.XOR<Prisma.CourseClassUpdateWithoutCourseInput, Prisma.CourseClassUncheckedUpdateWithoutCourseInput>
}

export type CourseClassUpdateManyWithWhereWithoutCourseInput = {
  where: Prisma.CourseClassScalarWhereInput
  data: Prisma.XOR<Prisma.CourseClassUpdateManyMutationInput, Prisma.CourseClassUncheckedUpdateManyWithoutCourseInput>
}

export type CourseClassCreateManyClassNameInput = {
  id?: string
  courseId: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CourseClassUpdateWithoutClassNameInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  course?: Prisma.CourseUpdateOneRequiredWithoutClassesNestedInput
}

export type CourseClassUncheckedUpdateWithoutClassNameInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CourseClassUncheckedUpdateManyWithoutClassNameInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CourseClassCreateManyCourseInput = {
  id?: string
  classId: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CourseClassUpdateWithoutCourseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  className?: Prisma.ClassNameUpdateOneRequiredWithoutCoursesNestedInput
}

export type CourseClassUncheckedUpdateWithoutCourseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  classId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CourseClassUncheckedUpdateManyWithoutCourseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  classId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type CourseClassSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  courseId?: boolean
  classId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  className?: boolean | Prisma.ClassNameDefaultArgs<ExtArgs>
}, ExtArgs["result"]["courseClass"]>

export type CourseClassSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  courseId?: boolean
  classId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  className?: boolean | Prisma.ClassNameDefaultArgs<ExtArgs>
}, ExtArgs["result"]["courseClass"]>

export type CourseClassSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  courseId?: boolean
  classId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  className?: boolean | Prisma.ClassNameDefaultArgs<ExtArgs>
}, ExtArgs["result"]["courseClass"]>

export type CourseClassSelectScalar = {
  id?: boolean
  courseId?: boolean
  classId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type CourseClassOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "courseId" | "classId" | "createdAt" | "updatedAt", ExtArgs["result"]["courseClass"]>
export type CourseClassInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  className?: boolean | Prisma.ClassNameDefaultArgs<ExtArgs>
}
export type CourseClassIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  className?: boolean | Prisma.ClassNameDefaultArgs<ExtArgs>
}
export type CourseClassIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  className?: boolean | Prisma.ClassNameDefaultArgs<ExtArgs>
}

export type $CourseClassPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "CourseClass"
  objects: {
    course: Prisma.$CoursePayload<ExtArgs>
    className: Prisma.$ClassNamePayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    courseId: string
    classId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["courseClass"]>
  composites: {}
}

export type CourseClassGetPayload<S extends boolean | null | undefined | CourseClassDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$CourseClassPayload, S>

export type CourseClassCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<CourseClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CourseClassCountAggregateInputType | true
  }

export interface CourseClassDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseClass'], meta: { name: 'CourseClass' } }
  /**
   * Find zero or one CourseClass that matches the filter.
   * @param {CourseClassFindUniqueArgs} args - Arguments to find a CourseClass
   * @example
   * // Get one CourseClass
   * const courseClass = await prisma.courseClass.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends CourseClassFindUniqueArgs>(args: Prisma.SelectSubset<T, CourseClassFindUniqueArgs<ExtArgs>>): Prisma.Prisma__CourseClassClient<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one CourseClass that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {CourseClassFindUniqueOrThrowArgs} args - Arguments to find a CourseClass
   * @example
   * // Get one CourseClass
   * const courseClass = await prisma.courseClass.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends CourseClassFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, CourseClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__CourseClassClient<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CourseClass that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseClassFindFirstArgs} args - Arguments to find a CourseClass
   * @example
   * // Get one CourseClass
   * const courseClass = await prisma.courseClass.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends CourseClassFindFirstArgs>(args?: Prisma.SelectSubset<T, CourseClassFindFirstArgs<ExtArgs>>): Prisma.Prisma__CourseClassClient<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CourseClass that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseClassFindFirstOrThrowArgs} args - Arguments to find a CourseClass
   * @example
   * // Get one CourseClass
   * const courseClass = await prisma.courseClass.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends CourseClassFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, CourseClassFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__CourseClassClient<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more CourseClasses that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseClassFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all CourseClasses
   * const courseClasses = await prisma.courseClass.findMany()
   * 
   * // Get first 10 CourseClasses
   * const courseClasses = await prisma.courseClass.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const courseClassWithIdOnly = await prisma.courseClass.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends CourseClassFindManyArgs>(args?: Prisma.SelectSubset<T, CourseClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a CourseClass.
   * @param {CourseClassCreateArgs} args - Arguments to create a CourseClass.
   * @example
   * // Create one CourseClass
   * const CourseClass = await prisma.courseClass.create({
   *   data: {
   *     // ... data to create a CourseClass
   *   }
   * })
   * 
   */
  create<T extends CourseClassCreateArgs>(args: Prisma.SelectSubset<T, CourseClassCreateArgs<ExtArgs>>): Prisma.Prisma__CourseClassClient<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many CourseClasses.
   * @param {CourseClassCreateManyArgs} args - Arguments to create many CourseClasses.
   * @example
   * // Create many CourseClasses
   * const courseClass = await prisma.courseClass.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends CourseClassCreateManyArgs>(args?: Prisma.SelectSubset<T, CourseClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many CourseClasses and returns the data saved in the database.
   * @param {CourseClassCreateManyAndReturnArgs} args - Arguments to create many CourseClasses.
   * @example
   * // Create many CourseClasses
   * const courseClass = await prisma.courseClass.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many CourseClasses and only return the `id`
   * const courseClassWithIdOnly = await prisma.courseClass.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends CourseClassCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, CourseClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a CourseClass.
   * @param {CourseClassDeleteArgs} args - Arguments to delete one CourseClass.
   * @example
   * // Delete one CourseClass
   * const CourseClass = await prisma.courseClass.delete({
   *   where: {
   *     // ... filter to delete one CourseClass
   *   }
   * })
   * 
   */
  delete<T extends CourseClassDeleteArgs>(args: Prisma.SelectSubset<T, CourseClassDeleteArgs<ExtArgs>>): Prisma.Prisma__CourseClassClient<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one CourseClass.
   * @param {CourseClassUpdateArgs} args - Arguments to update one CourseClass.
   * @example
   * // Update one CourseClass
   * const courseClass = await prisma.courseClass.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends CourseClassUpdateArgs>(args: Prisma.SelectSubset<T, CourseClassUpdateArgs<ExtArgs>>): Prisma.Prisma__CourseClassClient<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more CourseClasses.
   * @param {CourseClassDeleteManyArgs} args - Arguments to filter CourseClasses to delete.
   * @example
   * // Delete a few CourseClasses
   * const { count } = await prisma.courseClass.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends CourseClassDeleteManyArgs>(args?: Prisma.SelectSubset<T, CourseClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CourseClasses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseClassUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many CourseClasses
   * const courseClass = await prisma.courseClass.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends CourseClassUpdateManyArgs>(args: Prisma.SelectSubset<T, CourseClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CourseClasses and returns the data updated in the database.
   * @param {CourseClassUpdateManyAndReturnArgs} args - Arguments to update many CourseClasses.
   * @example
   * // Update many CourseClasses
   * const courseClass = await prisma.courseClass.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more CourseClasses and only return the `id`
   * const courseClassWithIdOnly = await prisma.courseClass.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends CourseClassUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, CourseClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one CourseClass.
   * @param {CourseClassUpsertArgs} args - Arguments to update or create a CourseClass.
   * @example
   * // Update or create a CourseClass
   * const courseClass = await prisma.courseClass.upsert({
   *   create: {
   *     // ... data to create a CourseClass
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the CourseClass we want to update
   *   }
   * })
   */
  upsert<T extends CourseClassUpsertArgs>(args: Prisma.SelectSubset<T, CourseClassUpsertArgs<ExtArgs>>): Prisma.Prisma__CourseClassClient<runtime.Types.Result.GetResult<Prisma.$CourseClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of CourseClasses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseClassCountArgs} args - Arguments to filter CourseClasses to count.
   * @example
   * // Count the number of CourseClasses
   * const count = await prisma.courseClass.count({
   *   where: {
   *     // ... the filter for the CourseClasses we want to count
   *   }
   * })
  **/
  count<T extends CourseClassCountArgs>(
    args?: Prisma.Subset<T, CourseClassCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], CourseClassCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a CourseClass.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends CourseClassAggregateArgs>(args: Prisma.Subset<T, CourseClassAggregateArgs>): Prisma.PrismaPromise<GetCourseClassAggregateType<T>>

  /**
   * Group by CourseClass.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseClassGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends CourseClassGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: CourseClassGroupByArgs['orderBy'] }
      : { orderBy?: CourseClassGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, CourseClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the CourseClass model
 */
readonly fields: CourseClassFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for CourseClass.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CourseClassClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  course<T extends Prisma.CourseDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CourseDefaultArgs<ExtArgs>>): Prisma.Prisma__CourseClient<runtime.Types.Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  className<T extends Prisma.ClassNameDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ClassNameDefaultArgs<ExtArgs>>): Prisma.Prisma__ClassNameClient<runtime.Types.Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the CourseClass model
 */
export interface CourseClassFieldRefs {
  readonly id: Prisma.FieldRef<"CourseClass", 'String'>
  readonly courseId: Prisma.FieldRef<"CourseClass", 'String'>
  readonly classId: Prisma.FieldRef<"CourseClass", 'String'>
  readonly createdAt: Prisma.FieldRef<"CourseClass", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"CourseClass", 'DateTime'>
}
    

// Custom InputTypes
/**
 * CourseClass findUnique
 */
export type CourseClassFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
  /**
   * Filter, which CourseClass to fetch.
   */
  where: Prisma.CourseClassWhereUniqueInput
}

/**
 * CourseClass findUniqueOrThrow
 */
export type CourseClassFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
  /**
   * Filter, which CourseClass to fetch.
   */
  where: Prisma.CourseClassWhereUniqueInput
}

/**
 * CourseClass findFirst
 */
export type CourseClassFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
  /**
   * Filter, which CourseClass to fetch.
   */
  where?: Prisma.CourseClassWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CourseClasses to fetch.
   */
  orderBy?: Prisma.CourseClassOrderByWithRelationInput | Prisma.CourseClassOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CourseClasses.
   */
  cursor?: Prisma.CourseClassWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CourseClasses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CourseClasses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CourseClasses.
   */
  distinct?: Prisma.CourseClassScalarFieldEnum | Prisma.CourseClassScalarFieldEnum[]
}

/**
 * CourseClass findFirstOrThrow
 */
export type CourseClassFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
  /**
   * Filter, which CourseClass to fetch.
   */
  where?: Prisma.CourseClassWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CourseClasses to fetch.
   */
  orderBy?: Prisma.CourseClassOrderByWithRelationInput | Prisma.CourseClassOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CourseClasses.
   */
  cursor?: Prisma.CourseClassWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CourseClasses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CourseClasses.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CourseClasses.
   */
  distinct?: Prisma.CourseClassScalarFieldEnum | Prisma.CourseClassScalarFieldEnum[]
}

/**
 * CourseClass findMany
 */
export type CourseClassFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
  /**
   * Filter, which CourseClasses to fetch.
   */
  where?: Prisma.CourseClassWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CourseClasses to fetch.
   */
  orderBy?: Prisma.CourseClassOrderByWithRelationInput | Prisma.CourseClassOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing CourseClasses.
   */
  cursor?: Prisma.CourseClassWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CourseClasses from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CourseClasses.
   */
  skip?: number
  distinct?: Prisma.CourseClassScalarFieldEnum | Prisma.CourseClassScalarFieldEnum[]
}

/**
 * CourseClass create
 */
export type CourseClassCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
  /**
   * The data needed to create a CourseClass.
   */
  data: Prisma.XOR<Prisma.CourseClassCreateInput, Prisma.CourseClassUncheckedCreateInput>
}

/**
 * CourseClass createMany
 */
export type CourseClassCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many CourseClasses.
   */
  data: Prisma.CourseClassCreateManyInput | Prisma.CourseClassCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * CourseClass createManyAndReturn
 */
export type CourseClassCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * The data used to create many CourseClasses.
   */
  data: Prisma.CourseClassCreateManyInput | Prisma.CourseClassCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * CourseClass update
 */
export type CourseClassUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
  /**
   * The data needed to update a CourseClass.
   */
  data: Prisma.XOR<Prisma.CourseClassUpdateInput, Prisma.CourseClassUncheckedUpdateInput>
  /**
   * Choose, which CourseClass to update.
   */
  where: Prisma.CourseClassWhereUniqueInput
}

/**
 * CourseClass updateMany
 */
export type CourseClassUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update CourseClasses.
   */
  data: Prisma.XOR<Prisma.CourseClassUpdateManyMutationInput, Prisma.CourseClassUncheckedUpdateManyInput>
  /**
   * Filter which CourseClasses to update
   */
  where?: Prisma.CourseClassWhereInput
  /**
   * Limit how many CourseClasses to update.
   */
  limit?: number
}

/**
 * CourseClass updateManyAndReturn
 */
export type CourseClassUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * The data used to update CourseClasses.
   */
  data: Prisma.XOR<Prisma.CourseClassUpdateManyMutationInput, Prisma.CourseClassUncheckedUpdateManyInput>
  /**
   * Filter which CourseClasses to update
   */
  where?: Prisma.CourseClassWhereInput
  /**
   * Limit how many CourseClasses to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * CourseClass upsert
 */
export type CourseClassUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
  /**
   * The filter to search for the CourseClass to update in case it exists.
   */
  where: Prisma.CourseClassWhereUniqueInput
  /**
   * In case the CourseClass found by the `where` argument doesn't exist, create a new CourseClass with this data.
   */
  create: Prisma.XOR<Prisma.CourseClassCreateInput, Prisma.CourseClassUncheckedCreateInput>
  /**
   * In case the CourseClass was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.CourseClassUpdateInput, Prisma.CourseClassUncheckedUpdateInput>
}

/**
 * CourseClass delete
 */
export type CourseClassDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
  /**
   * Filter which CourseClass to delete.
   */
  where: Prisma.CourseClassWhereUniqueInput
}

/**
 * CourseClass deleteMany
 */
export type CourseClassDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CourseClasses to delete
   */
  where?: Prisma.CourseClassWhereInput
  /**
   * Limit how many CourseClasses to delete.
   */
  limit?: number
}

/**
 * CourseClass without action
 */
export type CourseClassDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseClass
   */
  select?: Prisma.CourseClassSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseClass
   */
  omit?: Prisma.CourseClassOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseClassInclude<ExtArgs> | null
}
